-- phpMyAdmin SQL Dump
-- version 5.0.4
-- https://www.phpmyadmin.net/
--
-- Host: 127.0.0.1
-- Generation Time: Jun 03, 2021 at 07:34 AM
-- Server version: 10.4.16-MariaDB
-- PHP Version: 7.4.12

SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
START TRANSACTION;
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;

--
-- Database: `web-book-assembler`
--

-- --------------------------------------------------------

--
-- Table structure for table `lessons`
--

CREATE TABLE `lessons` (
  `id` int(11) NOT NULL,
  `title` varchar(100) NOT NULL,
  `body` text NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

--
-- Dumping data for table `lessons`
--

INSERT INTO `lessons` (`id`, `title`, `body`) VALUES
(1, 'Архитектура компьютера. Системы счисления. Биты и байты.', '<p>Успешное применение языка ассемблера невозможно без знания и понимания архитектуры компьютера и знания архитектуры конкретного процессора, для которого будет создаваться программа.</p>\r\n\r\n<p>Архитектура компьютера – это логическая организация, структура и ресурсы компьютера, которые может использовать программист.</p>\r\n\r\n<p>Архитектура компьютера включает в себя архитектуры отдельных устройств, входящих в компьютер. Хотя компьютер состоит из многих внешних и внутренних устройств, но реально программисту на ассемблере приходится работать только с тремя устройствами компьютерной системы: процессором, памятью и портами ввода-вывода. В сущности, эти три устройства определяют работу всего компьютера и работу всех внешних устройств подключенных к нему. Все эти три устройства соединены между собой при помощи трех основных шин: шиной данных (ШД), шиной адреса (ША) и шиной управления (ШУ) (рис. 1).</p>\r\n\r\n<img src=\"https://sites.google.com/site/sistprogr/_/rsrc/1464344305790/lekcii1/lek1/1.png\">\r\nРис. 1. Архитектура ЭВМ.\r\n\r\n<p>Процессор — электронный блок либо интегральная схема (микропроцессор), исполняющая машинные инструкции (код программ), главная часть аппаратного обеспечения компьютера или программируемого логического контроллера.</p>\r\n\r\n<p>Оперативная память предназначена для загрузки программ и для временного хранения различных данных, необходимых для работы программ.</p>\r\n\r\n<p>Порты ввода-вывода предназначены для взаимодействия с пользователем и другими устройствами.</p>\r\n\r\n<p>Шина (bus) – это группа параллельных проводников, с помощью которых данные передаются от одного устройства к другому:</p>\r\n\r\n<p>Шина данных (data bus) используется для обмена команд и данных между процессором и оперативной памятью, а также между устройствами ввода-вывода и ОЗУ.</p>\r\n\r\n<p>Шина управления (control bus) используется для передачи специальных сигналов, которые синхронизируют работу всех устройств, подключенных к системной шине. Например, процессор должен знать, когда можно читать информацию с шины данных. Для этого используется специальный сигнал готовности шины данных.</p>\r\n<p>Шина адреса (address bus) используется для указания адреса ячейки памяти в ОЗУ, к которой в текущий момент происходит обращение со стороны процессора или устройства ввода-вывода (чтение или запись).</p>\r\n<p>Все три шины вместе образуют системную шину или ее еще называют магистраль.</p>'),
(2, 'Процессор. Режимы работы процессора.', '<p>Самый основной элемент компьютера, это, конечно, процессор. Давайте подробней его рассмотрим. Упрощённая структура процессора:</p>\r\n\r\n\r\n<p>Основные элементы процессора:</p>\r\n\r\n<ul>\r\n\r\n<li>Регистры – это специальные ячейки памяти, физически расположенные внутри процессора. В отличие от ОЗУ, где для обращения к данным требуется использовать шину адреса, к регистрам процессор может обращаться напрямую. Это существенно ускорят работу с данными.</li>\r\n\r\n<li>Арифметико-логическое устройство выполняет арифметические операции, такие как сложение, вычитание, а также логические операции.</li>\r\n\r\n<li>Блок управления определяет последовательность микрокоманд, выполняемых при обработке машинных кодов (команд).</li>\r\n\r\n<li> Тактовый генератор, или генератор тактовых импульсов, задаёт рабочую частоту процессора.</li>\r\n</ul>\r\n\r\n<p>Режимы работы процессора.</p>\r\n\r\n<ol>\r\n\r\n<li>Реальный (незащищенный) режим (real address mode) — режим, в котором работал процессор 8086. В современных процессорах этот режим поддерживается в основном для совместимости с древним  программным обеспечением (DOS-программами).</li>\r\n\r\n<li>Защищенный режим (protected mode) — режим, который впервые был реализован в 80286  процессоре. Все современные операционные системы (Windows, Linux и пр.) работают в защищенном режиме. Программы реального режима не могут функционировать в защищенном режиме.</li>\r\n\r\n<li> Режим виртуального процессора 8086 (virtual-8086 mode, V86) — в этот режим можно перейти только из защищенного режима. Служит для обеспечения функционирования  программ  реального  режима,  причем дает возможность одновременной работы нескольких таких программ, что в реальном  режиме невозможно. Режим V86 предоставляет аппаратные средства для формирования виртуальной  машины, эмулирующей процессор8086. Виртуальная машина формируется программными  средствами  операционной  системы.  В Windows такая виртуальная машина называется VDM (Virtual DOS Machine — виртуальная машина DOS). VDM перехватывает и обрабатывает системные вызовы  от работающих DOS-приложений.</li>\r\n\r\n<li>Нереальный режим (unreal mode, он же big real mode) — аналогичен реальному режиму, только позволяет получать доступ ко всей физической памяти, что невозможно в реальном режиме.</li>\r\n\r\n<li>Режим системного управления System Management Mode (SMM) используется в служебных и отладочных целях.</li>\r\n</ol>'),
(3, 'Память', '<p>С точки зрения программиста память состоит из отдельных ячеек размером в байт (8 бит). Точнее память состоит из битов, но программист может оперировать только отдельными байтами. Если программе нужно изменить значение только одного бита, то она все равно должна считать целый байт, содержащий этот бит.</p>\r\n\r\n<p>Т.к. ячеек памяти, в отличие от процессорных регистров, огромное количество, то они не имеют названий как регистры процессора, а имеют просто уникальные числовые адреса, называемые физическими. Таким образом, память это просто огромный массив пронумерованных ячеек (нумерация начинается с нуля).</p>\r\n\r\n<p>Вся память делится на оперативную (ОЗУ) (по-английски RAM (Random Access Memory) — устройство с произвольным доступом) и постоянную память (ПЗУ) (ROM (Read Only Memory) — память только для чтения). Если в ОЗУ можно как записывать, так и считывать информацию, то из ПЗУ ее можно только считывать. В ПЗУ расположена BIOS и программа начальной загрузки компьютера (POST). Постоянная и оперативная память находятся в едином пространстве адресов.</p>\r\n\r\n<p>Важно помнить, что перед выполнением любая программа должна быть загружена в ОЗУ, только после этого процессор начинает последовательно считывать из нее и выполнять команды. Жесткие диски, дискеты, CD/DVD и прочие носители информации хранят файлы, которые будут выполнены только после того как будут загружены в память, причем образ на носителе информации не всегда соответствует тому образу, который будет перенесен в память. Переносом программы с носителя в память (и обратно, если необходимо) занимается операционная система.</p>\r\n\r\n<p>Загруженная в память программа всегда отводит под свои нужды отдельный участок памяти, который называется стеком. Стек работает особым образом — данные в него помещаются и извлекаются по принципу LIFO (Last In First Out — \"последним вошел– первым вышел\"). Стек можно представить в виде стопки листов бумаги (это, кстати, одно из значений английского слова stack) — листы, которые мы положили в стопку последними, сможем забрать первыми, иначе говоря, можем класть и забирать листы только с вершины стопки. Как вы помните, существуют специальные регистры, отведенные для работы со стеком это: SS, ESP, EBP. В системе Intel дно стека всегда расположено в больших адресах памяти, т. е. стек заполняется от максимально возможного адреса к меньшим. Программа и данные заполняют память, начиная с малых адресов памяти к большим. Между стеком и программой с данными существует промежуток из неиспользуемых адресов памяти.</p>\r\n\r\n<p>В реальном режиме процессор делит пространство памяти на сегменты по 64 Кбайт (сегментированная модель памяти), в защищенном режиме процессор предоставляет несколько различных моделей памяти, но чаще всего используется самая простая плоская модель памяти (память представляется одним сплошным массивом байтов).</p>\r\n\r\n<img src=\"https://sites.google.com/site/sistprogr/_/rsrc/1464348776478/lekcii1/lek3/1.png\">'),
(4, 'Основы языка Ассемблер. Синтаксис языка Ассемблер.', '<p>Язык ассемблера — тип языка программирования низкого уровня. Команды языка ассемблера один в один соответствуют командам процессора и представляют собой удобную символьную форму записи (мнемокод) команд и аргументов. Язык ассемблера обеспечивает связывание частей программы и данных через метки, выполняемое при ассемблировании (для каждой метки высчитывается адрес, после чего каждое вхождение метки заменяется на этот адрес).</p>\r\n\r\n<p>Каждая модель процессора имеет свой набор команд и соответствующий ему язык (или диалект) ассемблера.</p>\r\n\r\n<p>Обычно программы или участки кода пишутся на языке ассемблера в случаях, когда разработчику критически важно оптимизировать такие параметры, как быстродействие (например, при создании драйверов) и размер кода (загрузочные секторы, программное обеспечение для микроконтроллеров и процессоров с ограниченными ресурсами, вирусы, навесные защиты).</p>\r\n\r\n<p>Достоинства языков ассемблера.</p>\r\n\r\n<ol>\r\n\r\n<li>Максимально оптимальное использование средств процессора, использование меньшего количества команд и обращений в память и, как следствие, большая скорость и меньший размер программы.</li>\r\n\r\n<li>Использование расширенных наборов инструкций процессора (MMX, SSE, SSE2, SSE3).</li>\r\n\r\n<li>Доступ к портам ввода-вывода и особым регистрам процессора (в большинстве ОС эта возможность доступна только на уровне модулей ядра и драйверов)</li>\r\n\r\n<li>Возможность использования самомодифицирующегося (в том числе перемещаемого) кода (под многими платформами она недоступна, так как запись в страницы кода запрещена, в том числе и аппаратно, однако в большинстве общедоступных систем из-за их врожденных недостатков имеется возможность исполнения кода, содержащегося в сегменте (секции) данных, куда запись разрешена).</li>\r\n\r\n<li>Максимальная адаптация для нужной платформы.</li>\r\n\r\n<p>Синтаксис ассемблера.</p>\r\n\r\n<p>Синтаксис общих элементов языка. В отличие от языков программирования высокого уровня, где основным элементом языка является оператор, синтаксически программа на ассемблере состоит из последовательности строк. Строка – основная единица ассемблерной программы.</p>\r\n\r\n<p>Синтаксис строки имеет следующий общий вид:</p>\r\n\r\n<p><метка:> <команда или директива> <операнды> <;комметарий></p>\r\n\r\n<p>Все эти четыре поля необязательны, в программе вполне могут присутствовать и полностью пустые строки для выделения каких либо блоков кода. Метка может быть любой комбинацией букв английского алфавита, цифр и символов _, $, @, ?, но цифра не может быть первым символом метки, а символы $ и ? иногда имеют специальные значения и обычно не рекомендуются к использованию. Большие и маленькие буквы по умолчанию не различаются, но различие можно включить, задав ту или иную опцию в командной строке ассемблера. Во втором поле, поле команды, может располагаться команда процессора, которая транслируется в исполняемый код, или директива, которая не приводит к появлению нового кода, а управляет работой самого ассемблера. В поле операндов располагаются требуемые командой или директивой операнды (то есть нельзя указать операнды и не указать команду или директиву). И наконец, в поле комментариев, начало которого отмечается символом ; (точка с запятой), можно написать все что угодно — текст от символа «;» до конца строки не анализируется ассемблером.</p>\r\n\r\n</ol>'),
(5, 'Способы задания адресов хранения операндов (способы адресации).', '<p>Способы адресации в командах языка Assembler.</p>\r\n\r\n<p>Большинство команд процессора вызываются с аргументами, которые в ассемблере принято называть операндами. Например: команда сложения содержимого регистра с числом требует задания двух операндов – содержимого регистра и числа. Далее рассмотрены все существующие способы задания адреса хранения операндов – способы адресации.</p>\r\n\r\n<p>Все имеющиеся способы адресации можно условно разделить на три группы: регистровая, непосредственная и с указанием адреса памяти. При этом адрес памяти можно задавать по-разному: прямым указанием символического обозначения ячейки памяти, указанием регистра, в котором хранится требуемый адрес, или и того и другого. Таким образом, третья группа включает, в сущности, целый ряд способов адресации. Они обычно носят названия: прямая, базовая, индексная, базово-индексная, а также базовая, индексная или базово-индексная со смещением.</p>\r\n\r\n<p>Регистровая адресация.</p>\r\n\r\n<p>Операнды могут располагаться в любых регистрах общего назначения и сегментных регистрах. Для этого в тексте программы указывается название соответствующего регистра, например: команда, копирующая в регистр АХ содержимое регистра ВХ, записывается как</p>\r\n\r\n<code>mov ax, bx</code>\r\n\r\n<p>Непосредственная адресация.</p>\r\n\r\n<p>Некоторые команды (все арифметические, кроме деления) позволяют указывать один из операндов непосредственно в тексте программы. Например: команда</p>\r\n\r\n<code>mov ax, 2</code>\r\n\r\n<p>Прямая адресация.</p>\r\n\r\n<code>mov DL,meml ;Содержимое байта памяти с символическим именем meml; пересылается в DL</code>\r\n\r\n<p>Базовая и индексная адресация памяти.</p>\r\n\r\n<p>Относительный  адрес  ячейки  памяти  находится  в  регистре,  обозначение  которого  заключается в квадратные скобки. При использовании  регистров  ВХ  или  ВР  адресацию  называют  базовой, при использовании  регистров SI или  DI  -  индексной.  При адресации  через регистры  ВХ, SI  или DI  в качестве сегментного регистра подразумевается DS; при адресации через ВР - регистр SS. Таким образом, косвенная адресация через регистр ВР предназначена для работы со стеком. Однако при необходимости можно явно указать  требуемый  сегментный  регистр.  Еще  раз  отметим,  что  во  всех  базовых  и  индексных  способах адресации операндом является содержимое ячейки памяти, адрес которой находится в том или ином регистре или вычисляется сложением содержимого двух регистров</p>\r\n\r\n<code>mov AL,[ВХ] ;Сегментный адрес предполагается в DS, смещение в ВХ</code>'),
(6, 'Команды пересылки и обмена данными языка Ассемблер.', '<p>Команда пересылки MOV.</p>\r\n\r\n<p>Команда MOV копирует данные из операнда-источника в операнд-получатель. Она относится к группе команд пересылки данных (data transfer) и используется в любой программе. Команда MOV является двуместной (т.е. имеет два операнда): первый операнд определяет получателя данных (destination), а второй — источник данных (source):</p>\r\n\r\n<code>MOV <получатель>, <источник></code>\r\n\r\n<p>При выполнении этой команды изменяется содержимое операнда-получателя, а содержимое операнда-источника не меняется. Принцип пересылки данных справа налево соответствует принятому в операторах присваивания языков высокого уровня, таких как C++:</p>\r\n\r\n<code><получатель> = <источник>;</code>\r\n\r\n<p>Практически во всех командах ассемблера операнд-получатель находится слева, а операнд-источник— справа.</p>\r\n\r\n<p>В команде MOV могут использоваться самые разные операнды. Кроме того, необходимо учитывать следующие правила и ограничения:</p>\r\n\r\n<ol>\r\n\r\n<li>Оба операнда должны иметь одинаковую длину.</li>\r\n\r\n<li>В качестве одного из операндов обязательно должен использоваться регистр (т.е. пересылки типа \"память-память\" в команде MOV не поддерживаются).</li>\r\n\r\n<li>В качестве получателя нельзя указывать регистры CS, EIP и IP.</li>\r\n\r\n<li>Нельзя переслать непосредственно заданное значение в сегментный регистр.</li>\r\n\r\n</ol>\r\n\r\n<p>Практически во всех командах ассемблера операнд-получатель находится слева, а операнд-источник— справа.</p>\r\n\r\n<p>Команда MOVZX.</p>\r\n\r\n<p>Команда  MOVZX  (Move  With  Zero-Extend,  или  Переместить  и  дополнить  нулями)  копирует содержимое  исходного  операнда  в  больший  по  размеру  регистр  получателя  данных.  При  этом оставшиеся  неопределенными  биты  регистра-получателя  (как  правило,  старшие  16  или  24  бита) сбрасываются  в  ноль. Эта  команда  используется  только  при  работе с  беззнаковыми целыми  числами. Существует три варианта команды MOVZX:</p>\r\n\r\n<code>MOVZX  r16, r/m8</code>\r\n\r\n<code>MOVZX  r32, r/m8</code>\r\n\r\n<code>MOVZX  r32, r/m16</code>\r\n\r\n<p>Команда  MOVSX  (Move  With  Sign-Extend,  или  переместить  и  дополнить  знаком)  копирует содержимое  исходного  операнда  в  больший  по  размеру  регистр  получателя  данных,  также  как  и команда  MOVZX.  При  этом  оставшиеся  неопределенными  биты  регистра-получателя  (как  правило, старшие  16  или  24  бита)  заполняются  значением  знакового  бита  исходного  операнда.  Эта  команда используется  только  при  работе  со  знаковыми  целыми  числами.  Существует  три  варианта  команды MOVSX:</p>\r\n\r\n<code>MOVZX  r16, r/m8</code>\r\n\r\n<code>MOVZX  r32, r/m8</code>\r\n\r\n<code>MOVZX  r32, r/m16</code>\r\n\r\n\r\n\r\n'),
(7, 'Арифметические команды языка Ассемблер', '<p>Сложение и вычитание.</p>\r\n\r\n<p>ADD – команда для сложения двух чисел. Она работает как с числами со знаком, так и без знака.</p>\r\n\r\n<code>ADD Приемник, Источник</code>\r\n\r\n<p>Логика работы команды:</p>\r\n\r\n<code>\r\n	<Приемник> = <Приемник> + <Источник>\r\n</code>\r\n\r\n<p>Возможные сочетания операндов для этой команды аналогичны команде MOV.</p>\r\n\r\n<p>Операнды должны иметь одинаковый размер. Результат помещается на место первого операнда.</p>\r\n\r\n<p>После выполнения команды изменяются флаги, по которым можно определить характеристики результата:</p>\r\n\r\n<ol>\r\n\r\n	<li>Флаг CF устанавливается, если при сложении произошёл перенос из старшего разряда. Для беззнаковых чисел это будет означать, что произошло переполнение и результат получился некорректным.</li>\r\n\r\n	<li>Флаг OF обозначает переполнение для чисел со знаком.</li>\r\n\r\n	<li>Флаг SF равен знаковому биту результата (естественно, для чисел со знаком, а для беззнаковых он равен старшему биту и особо смысла не имеет).</li>\r\n\r\n	<li>Флаг ZF устанавливается, если результат равен 0.</li>\r\n\r\n	<li>Флаг PF — признак чётности, равен 1, если результат содержит нечётное число единиц.</li>\r\n\r\n</ol>\r\n\r\n<p>SUB - команда для вычитания одного числа из другого. Она работает как с числами со знаком, так и без знака.</p>\r\n\r\n<code>SUB Приемник, Источник</code>\r\n\r\n<p>Логика работы команды:</p>\r\n\r\n<code>\r\n	<Приемник> = <Приемник> - <Источник>\r\n</code>\r\n\r\n<p>Инкремент и декремент. Очень часто в программах используется операция прибавления или вычитания единицы. Прибавление единицы называется инкрементом, а вычитание — декрементом. Для этих операций существуют специальные команды процессора: INC и DEC. Эти команды не изменяют значение флага CF.</p>\r\n\r\n<p>Эти команды содержит один операнд и имеет следующий синтаксис:</p>\r\n\r\n<code>INC Операнд</code>\r\n\r\n<code>DEC Операнд</code>\r\n\r\n<p>Логика работы команд:</p>\r\n\r\n<code>INC: <Операнд> = < Операнд> + 1</code>\r\n\r\n<code>DEC: <Операнд> = < Операнд> - 1</code>'),
(8, 'Логические команды языка Ассемблер', '<p>Команда AND.</p>\r\n\r\n<p>	\r\nВыполняет операцию логического И между двумя операндами</p>\r\n\r\n<p>Команда OR.</p>\r\n\r\n<p>	\r\nВыполняет операцию логического ИЛИ между двумя операндами</p>\r\n\r\n<p>Команда XOR.</p>\r\n\r\n<p>	\r\nВыполняет операцию исключающего ИЛИ между двумя операндами</p>\r\n\r\n<p>Команда NOT.</p>\r\n\r\n<p>	\r\nВыполняет операцию логического отрицание (НЕ) единственного операнда</p>\r\n\r\n<p>Команда BT, BTC, BTR, BTS.</p>\r\n\r\n<p>	\r\nКопирует бит операнда получателя, номер n которого задан в исходном операнде, во флаг переноса (CF), а затем, в зависимости от команды, тестирует, инвертирует, сбрасывает или устанавливает этот же бит операнда получателя</p>\r\n\r\n<p>Команда TEST.</p>\r\n\r\n<p>	\r\nВыполняет операцию логического И между двумя операндами, устанавливает соответствующие флаги состояния процессора, но результат операции не записывается вместо операнда получателя данных</p>'),
(9, 'Команды безусловного и условного переходов в языке Ассемблер', '<p>Безусловный переход</p>\r\n\r\n<p>Команда безусловного перехода имеет следующий синтаксис:</p>\r\n\r\n<code>JMP <операнд></code>\r\n\r\n<p>Операнд указывает адрес перехода. Существует два способа указания этого адреса, соответственно различают прямой и косвенный переходы.</p>\r\n\r\n<p>Прямой переход</p>\r\n\r\n<p>Если в команде перехода указывается метка команды, на которую надо перейти, то переход называется прямым.</p>\r\n\r\n<code>jmp L</code>\r\n\r\n<code>...</code>\r\n\r\n<code>...</code>\r\n\r\n<code>L: mov eax, x</code>\r\n\r\n<p>Косвенный переход</p>\r\n\r\n<p>При косвенном переходе в команде перехода указывается не адрес перехода, а регистр или ячейка памяти, где этот адрес находится. Содержимое указанного регистра или ячейки памяти рассматривается как абсолютный адрес перехода. Косвенные переходы используются в тех случаях, когда адрес перехода становится известен только во время работы программы.</p>\r\n\r\n<code>jmp ebx</code>\r\n\r\n<p>В системе команд процессора архитектуры x86 не предусмотрена поддержка условных логических структур, характерных для языков высокого уровня. Однако на языке ассемблера с помощью набора команд сравнения и условного перехода вы можете реализовать логическую структуру любой сложности. В языке высокого уровня любой условный оператор выполняется в два этапа. Сначала вычисляется значение условного выражения, а затем, в зависимости от его результата, выполняются те или иные действия. Проводя аналогию с языком ассемблера, можно сказать, что сначала выполняются такие команды, как CMP, AND или SUB, влияющие на флаги состояния процессора. Затем выполняется команда условного перехода, которая анализирует значение нужных флагов, и в случае если они установлены, выполняют переход по указанному адресу.</p>\r\n\r\n<p>Что касается команд условного перехода, то их достаточно много, но все они записываются единообразно:</p>\r\n\r\n<code>Jxx <метка></code>\r\n\r\n<p>Все команды условного перехода можно разделить на три группы.</p>\r\n\r\n<p>В первую группу входят команды, которые обычно ставятся после команды сравнения. В их мнемокодах указывается тот результат сравнения, при котором надо делать переход.</p>\r\n\r\n<table>\r\n\r\n<tr>\r\n<td>Мнемокод</td>\r\n<td>Название</td>\r\n<td>Условие перехода после команды CMP op1, op2</td>\r\n<td>Значения флагов</td>\r\n<td>Примечание</td>\r\n</tr>\r\n\r\n<tr>\r\n<td>JE</td>\r\n<td>Переход если равно</td>\r\n<td>op1 = op2</td>\r\n<td>ZF = 1</td>\r\n<td>Для всех чисел</td>\r\n</tr>\r\n\r\n<tr>\r\n<td>JNE</td>\r\n<td>Переход если не равно</td>\r\n<td>op1 ≠ op2</td>\r\n<td>ZF = 0</td>\r\n<td>Для всех чисел</td>\r\n</tr>\r\n\r\n<tr>\r\n<td>JL/JNGE</td>\r\n<td>Переход если меньше</td>\r\n<td>op1 < op2</td>\r\n<td>SF ≠ OF</td>\r\n<td>Для чисел со знаком</td>\r\n</tr>\r\n\r\n<tr>\r\n<td>JB/JNAE</td>\r\n<td>Переход если ниже</td>\r\n<td>op1 < op2</td>\r\n<td>CF = 1</td>\r\n<td>Для чисел без знака</td>\r\n</tr>\r\n\r\n</table>');

--
-- Indexes for dumped tables
--

--
-- Indexes for table `lessons`
--
ALTER TABLE `lessons`
  ADD PRIMARY KEY (`id`);

--
-- AUTO_INCREMENT for dumped tables
--

--
-- AUTO_INCREMENT for table `lessons`
--
ALTER TABLE `lessons`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=10;
COMMIT;

/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
